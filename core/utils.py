import os
import re
import shutil
import json
import logging
import glob
import copy
import subprocess
from os.path import join

import numpy as np
import torch
import torch.nn as nn
import torch.nn.functional as F
import torch.distributed as dist
from torch.optim import lr_scheduler


def get_epochs_from_ckpt(filename):
  regex = "(?<=ckpt-)[0-9]+"
  return int(re.findall(regex, filename)[-1])

def get_list_checkpoints(train_dir):
  files = glob.glob(join(train_dir, "checkpoints", "model.ckpt-*.pth"))
  files = sorted(files, key=get_epochs_from_ckpt)
  return [filename for filename in files]


class MessageBuilder:

  def __init__(self):
    self.msg = []

  def add(self, name, values, align=">", width=0, format=None):
    if name:
      metric_str = "{}: ".format(name)
    else:
      metric_str = ""
    values_str = []
    if type(values) != list:
      values = [values]
    for value in values:
      if format:
        values_str.append("{value:{align}{width}{format}}".format(
          value=value, align=align, width=width, format=format))
      else:
        values_str.append("{value:{align}{width}}".format(
          value=value, align=align, width=width))
    metric_str += '/'.join(values_str)
    self.msg.append(metric_str)

  def get_message(self):
    message = " | ".join(self.msg)
    self.clear()
    return message

  def clear(self):
    self.msg = []


def setup_logging(config, rank):
  level = {'DEBUG': 10, 'ERROR': 40, 'FATAL': 50,
    'INFO': 20, 'WARN': 30
  }[config.logging_verbosity]
  format_ = "[%(asctime)s %(filename)s:%(lineno)s] %(message)s"
  filename = '{}/log_{}_{}.logs'.format(config.train_dir, config.mode, rank)
  logging.basicConfig(filename=filename, level=level, format=format_, datefmt='%H:%M:%S')


def setup_distributed_training(world_size, rank):
  """ find a common host name on all nodes and setup distributed training """
  # make sure http proxy are unset, in order for the nodes to communicate
  for var in ['http_proxy', 'https_proxy']:
    if var in os.environ:
      del os.environ[var]
    if var.upper() in os.environ:
      del os.environ[var.upper()]
  # get distributed url 
  # cmd = 'scontrol show hostnames ' + os.getenv('SLURM_JOB_NODELIST')
  # stdout = subprocess.check_output(cmd.split())
  # host_name = stdout.decode().splitlines()[0]
  # dist_url = f'tcp://{host_name}:9000'
  dist_url = f'tcp://localhost:9000'
  # setup dist.init_process_group
  dist.init_process_group(backend='nccl', init_method=dist_url,
    world_size=world_size, rank=rank)


class LossXent(nn.Module):

  def __init__(self, config):
    super(LossXent, self).__init__()
    self.criterion = nn.CrossEntropyLoss()
    self.n_classes = {
      'mnist': 10,
      'cifar10': 10,
      'cifar100': 100,
    }[config.dataset]
    self.offset = config.offset
    self.temperature = config.temperature

  def __call__(self, outputs, labels):
    one_hot_labels = F.one_hot(labels, num_classes=self.n_classes)
    offset_outputs = outputs - self.offset * one_hot_labels
    offset_outputs /= self.temperature
    loss = self.criterion(offset_outputs, labels) * self.temperature
    return loss


class TriangularLRScheduler:

  def __init__(self, optimizer, num_steps, lr):
    self.optimizer = optimizer
    self.num_steps = num_steps
    self.lr = lr

  def step(self, t):
    lr = np.interp([t],
      [0, self.num_steps * 2 // 5, self.num_steps * 4 // 5, self.num_steps],
      [0, self.lr, self.lr / 20.0, 0])[0]
    self.optimizer.param_groups[0].update(lr=lr)


